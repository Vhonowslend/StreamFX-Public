// AUTOGENERATED COPYRIGHT HEADER START
// Copyright (C) 2019-2023 Michael Fabian 'Xaymar' Dirks <info@xaymar.com>
// AUTOGENERATED COPYRIGHT HEADER END

// -------------------------------------------------------------------------------- //
// Parameters
/// Provided by OBS Studio.
uniform float4x4 ViewProj <
	bool visible = false;
	bool disabled = true;
>;

uniform texture2d pMaskInputA <
	string name = "Mask Input A";
	string description = "Input to mask.";
>;
uniform texture2d pMaskInputB <
	string name = "Mask Input B";
	string description = "Input to use as the mask.";
>;

uniform float4 pMaskBase <
	string name = "Channel Base";
//	float4 minimum = float4(-100.0, -100.0, -100.0, -100.0);
//	float4 maximum = float4(100.0, 100.0, 100.0, 100.0);
//	float4 default = float4(1, 1, 1, 1);
>;
uniform float4x4 pMaskMatrix <
	string name = "Channel Matrix";
//	float4 minimum = float4x4(
//		-100, -100, -100, -100,
//		-100, -100, -100, -100,
//		-100, -100, -100, -100,
//		-100, -100, -100, -100);
//	float4 maximum = float4x4(
//		100, 100, 100, 100,
//		100, 100, 100, 100,
//		100, 100, 100, 100,
//		100, 100, 100, 100);
//	float4 default = float4x4(
//		1, 0, 0, 0,
//		0, 1, 0, 0,
//		0, 0, 1, 0,
//		0, 0, 0, 1);
>;
/* pMaskMatrix Content:
 *   [Red,Green,Blue,Alpha] (Red)
 *   [Red,Green,Blue,Alpha] (Green)
 *   [Red,Green,Blue,Alpha] (Blue)
 *   [Red,Green,Blue,Alpha] (Alpha)
 */

uniform float4 pMaskMultiplier <
	string name = "Channel Multiplier";
//	float4 minimum = float4(-100, -100, -100, -100);
//	float4 maximum = float4(100, 100, 100, 100);
//	float4 default = float4(1, 1, 1, 1);
>;
// -------------------------------------------------------------------------------- //

// -------------------------------------------------------------------------------- //
// Samplers
sampler_state maskSamplerA {
	Filter		= Linear;
	AddressU	= Clamp;
	AddressV	= Clamp;
};

sampler_state maskSamplerB {
	Filter		= Linear;
	AddressU	= Clamp;
	AddressV	= Clamp;
};
// -------------------------------------------------------------------------------- //

// -------------------------------------------------------------------------------- //
// Default Vertex Shader
struct VertDataIn {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

struct VertDataOut {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertDataOut VSDefault(VertDataIn v_in)
{
	VertDataOut vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}
// -------------------------------------------------------------------------------- //

// -------------------------------------------------------------------------------- //
// Channel Masking

float4 PSChannelMask(VertDataOut v_in) : TARGET
{
	// Sample both inputs at current UV.
	float4 imageA = pMaskInputA.Sample(maskSamplerA, v_in.uv);
	float4 imageB = pMaskInputB.Sample(maskSamplerB, v_in.uv);

	// Assign the base value as the mask.
	float4 mask = pMaskBase;

	// pMaskMatrix[0] contains all the "x Value from Red Input"
	mask += pMaskMatrix[0] * imageB.r;
	
	// pMaskMatrix[1] contains all the "x Value from Green Input"
	mask += pMaskMatrix[1] * imageB.g;
	
	// pMaskMatrix[2] contains all the "x Value from Blue Input"
	mask += pMaskMatrix[2] * imageB.b;
	
	// pMaskMatrix[3] contains all the "x Value from Alpha Input"
	mask += pMaskMatrix[3] * imageB.a;

	// Multiply the mask value by the per channel multiplier.
	mask *= pMaskMultiplier;

	// And finally multiply the input image with the mask.
	return imageA * mask;
}

technique Mask
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader = PSChannelMask(v_in);
	}
}
// -------------------------------------------------------------------------------- //
